# 依赖注入思想理解
指导文档 [依赖注入（DI）在PHP中的实现](https://www.jianshu.com/p/cb0693dd8d2e)

## 1.自己理解

依赖注入其实是所有类都依赖于 DI 容器，将依赖容器注入到自身，然后利用依赖容器去加载所需要的依赖。

ioc 是控制反转，是对象将依赖的控制权交由其他对象管理，di是依赖注入
意思是 依赖交由注入容器控制。

ioc（控制反转） 和 DI（依赖注入）  的联系与区别。
ioc是一种思想，di是 ioc 思想的一个实现。相当于 ioc是接口di是实现的类。


## 2.网上理解

"依赖倒置是一种软件设计思想，在传统软件中，上层代码依赖于下层代码，当下层代码有所改动时，上层代码也要相应进行改动，因此维护成本较高。而依赖倒置原则的思想是，上层不应该依赖下层，应依赖接口。意为上层代码定义接口，下层代码实现该接口，从而使得下层依赖于上层接口，降低耦合度，提高系统弹性"

### 理解 1.

>IOC是个更宽泛的概念，DI是更具体的。引用郑烨的一篇博客，我眼中的Spring
Dependency Injection原来，它叫IoC。Martin Flower发话了，是个框架都有IoC，这不足以新生容器反转的“如何定位插件的具体实现”，于是，它有了个新名字，Dependency Injection。其实，它就是一种将调用者与被调用者分离的思想，Uncle Bob管它叫DIP（Dependency Inversion Principle），并把它归入OO设计原则。同Spring相比，它更早进入我的大脑。一切都是那么朦胧，直至Spring出现。慢慢的，我知道了它还分为Interface Injection（type 1），Setter Injection（type 2），Constructor Injection（type 3）。Martin Flower那篇为它更名的大作让我心目关于它的一切趋于完整。在Spring中，它是一切的基础。Spring的种种优势随之而来。于我而言，它为我带来更多的是思维方式的转变，恐怕以后我再也无法写出那种一大块的全功能程序了。

作者：灵魂机器
链接：https://www.zhihu.com/question/25392984/answer/45224293
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


ioc是目的，di是手段。ioc是指让生成类的方式由传统方式（new）反过来，既程序员不调用new,需要类的时候由框架注入（di），是同一件不同层面的解读。

### 理解 2.

<div class="RichContent-inner"><span class="RichText ztext CopyrightRichText-richText" itemprop="text"><p>废话1：有的朋友可能把依赖倒置(DIP)和依赖注入(DI)弄混了。</p>《敏捷软件开发》第11章：<br><blockquote>依赖倒置原则<br>a.高层模块不应该依赖于底层模块，二者都应该依赖于抽象。<br>b.抽象不应该依赖于细节，细节应该依赖于抽象。</blockquote><br><p>可见，依赖倒置的本质是<u>依赖抽象</u>，这与依赖注入的本质<u>依赖容器</u>，是两回事。</p><p>换句话说，如果Java没有接口、多态，依赖倒置就无从谈起。<br>而依赖注入依然可以存在，只要有一个注册表（《企业应用架构模式》第18章第5节）定义bean，利用反射来实例化并装配bean，有个容器容纳它们即可。</p><br><br><br><p>废话2：还有的朋友可能把控制反转(IoC)和依赖注入(DI)混为一谈了。</p>《EXPERT ONE ON ONE J2EE DEVELOPMENT WITHOUT EJB》第6章：<br><blockquote>IoC主要的实现方式有两种：依赖查找，依赖注入。(128页)<br>依赖注入是一种更可取的方式。(130页)</blockquote><br>流行的「Martin Fowler将IoC改名为DI」的说法，Martin Fowler的原文在这里：<br><a href="https://link.zhihu.com/?target=http%3A//martinfowler.com/articles/injection.html" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Inversion of Control Containers and the Dependency Injection
	pattern</a><br><blockquote>As a result I think we need a more specific name for this pattern. Inversion of Control is too generic a term, and thus people find it confusing. As a result with a lot of discussion with various IoC advocates we settled on the name Dependency Injection.</blockquote>大意是<br><blockquote>已经存在某种模式，该模式被称为IoC，但IoC太普遍，任何框架都IoC，为了让表意更明确，决定用DI来精确指称那个模式。</blockquote>意思大概就是<br><blockquote>IoC ioc = the_pattern;<br>DI di = (DI)ioc;</blockquote><p>显然，说the_pattern是IoC或DI都行，多态。但严格说IoC.class == DI.class肯定不为真，两者还是有区别，是 is-a 的关系。<br>不过正如不少人把Service和ServiceImpl分开，但Service事实上永远只有一个ServiceImpl实现一样，IoC虽然理论上还有其他实现，但DI过于主流，以至于混用了。</p><br><br><br><p>废话说完了，正面答题：</p>题主虽然问的是IoC，但可以确定在问DI。依赖注入的好处，各位说得差不多了，不赘。<br>《Spring实战》第1章：<br><blockquote>在项目中应用DI，你会发现你的代码会变得<u>异常简单</u>并且更容易<u>理解</u>和<u>测试</u>。</blockquote><br><p>另外说说<u>不限于DI的IoC</u>，你的代码不再被直接调用，而是被框架代码调用，所以说<u>框架与类库的区别在于控制反转</u>( 好莱坞原则，don't call me, i'll call you )。<br>往大了说，http请求不由你的Servlet/Filter直接处理，而是由Struts/Spring MVC的Servlet/Filter处理，再分配给你的组件，这也算IoC。<br>往小了说，操作数据库不再由你直接写jdbc的一大堆try嵌套，而是把固定的部分抽到JdbcTemplate中，你只负责写局部代码，然后由框架调你的局部代码，这也算IoC。<br>前一种，也就是前端控制器模式（《企业应用架构模式》第14章第3节），后一种，也就是模板方法模式（《设计模式》第5章第10节）。当然，除此之外还有很多。</p>所以说，IoC的好处，也就是框架的好处。<br>《Struts2技术内幕》第2章：<br><blockquote>框架是一组程序的集合，包含了一系列的最佳实践，作用是<u>解决某个领域的问题</u>。</blockquote><p>这说得很对，但把框架换成类库也适用。</p>关于框架的好处，在stackoverflow上一个问题下的答案我很喜欢：<a href="https://link.zhihu.com/?target=http%3A//stackoverflow.com/a/148759/6640026" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">What is the difference between a framework and a library?</a><br>大意是：<br><blockquote>框架提供了骨架，你只要提供肉就可以了，你的肉<u>在骨架中被调用</u>。</blockquote><br><p>我认为，这就是控制反转的意义。<br>框架提供了骨架（通用代码），你提供肉（业务逻辑）就行了。<br>你的肉在骨架中被调用（如web容器先调用框架，框架再调用你的代码，而不是你的代码直接被web容器调用）。</p><b><u>这让你专心于业务。</u></b></span></div>

### 理解 3.

<div class="RichContent RichContent--unescapable"><div class="RichContent-inner RichContent-inner--collapsed"><span class="RichText ztext CopyrightRichText-richText" itemprop="text"><p>要了解<b>控制反转( Inversion of Control )</b>, 我觉得有必要先了解软件设计的一个重要思想：<b>依赖倒置原则（Dependency Inversion Principle ）</b>。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-d53c75e91d959acbb0d95a835212ada5_hd.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png"></figure><p><b>什么是依赖倒置原则？</b>假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-c68248bb5d9b4d64d22600571e996446_b.png" data-caption="" data-rawwidth="1562" data-rawheight="186" class="origin_image zh-lightbox-thumb" width="1562" data-original="https://pic3.zhimg.com/v2-c68248bb5d9b4d64d22600571e996446_r.jpg"></noscript><img src="https://pic3.zhimg.com/80/v2-c68248bb5d9b4d64d22600571e996446_hd.png" data-caption="" data-rawwidth="1562" data-rawheight="186" class="origin_image zh-lightbox-thumb lazy" width="1562" data-original="https://pic3.zhimg.com/v2-c68248bb5d9b4d64d22600571e996446_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c68248bb5d9b4d64d22600571e996446_b.png"></figure><p>这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！</p><p>我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-e64bf72c5c04412f626b21753aa9e1a1_b.png" data-caption="" data-rawwidth="1504" data-rawheight="190" class="origin_image zh-lightbox-thumb" width="1504" data-original="https://pic2.zhimg.com/v2-e64bf72c5c04412f626b21753aa9e1a1_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-e64bf72c5c04412f626b21753aa9e1a1_hd.png" data-caption="" data-rawwidth="1504" data-rawheight="190" class="origin_image zh-lightbox-thumb lazy" width="1504" data-original="https://pic2.zhimg.com/v2-e64bf72c5c04412f626b21753aa9e1a1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e64bf72c5c04412f626b21753aa9e1a1_b.png"></figure><p>这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。</p><p>这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-d53c75e91d959acbb0d95a835212ada5_hd.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png"></figure><p><b>控制反转（Inversion of Control）</b> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<b>依赖注入（Dependency Injection）</b>。其实这些概念初次接触都会感到云里雾里的。说穿了，这几种概念的关系大概如下：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-ee924f8693cff51785ad6637ac5b21c1_b.png" data-caption="" data-rawwidth="1398" data-rawheight="630" class="origin_image zh-lightbox-thumb" width="1398" data-original="https://pic2.zhimg.com/v2-ee924f8693cff51785ad6637ac5b21c1_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-ee924f8693cff51785ad6637ac5b21c1_hd.png" data-caption="" data-rawwidth="1398" data-rawheight="630" class="origin_image zh-lightbox-thumb lazy" width="1398" data-original="https://pic2.zhimg.com/v2-ee924f8693cff51785ad6637ac5b21c1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ee924f8693cff51785ad6637ac5b21c1_b.png"></figure><p>为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个Class，车，车身，底盘，轮胎。然后初始化这辆车，最后跑这辆车。代码结构如下：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-8ec294de7d0f9013788e3fb5c76069ef_b.png" data-caption="" data-rawwidth="512" data-rawheight="717" class="origin_image zh-lightbox-thumb" width="512" data-original="https://pic4.zhimg.com/v2-8ec294de7d0f9013788e3fb5c76069ef_r.jpg"></noscript><img src="https://pic4.zhimg.com/80/v2-8ec294de7d0f9013788e3fb5c76069ef_hd.png" data-caption="" data-rawwidth="512" data-rawheight="717" class="origin_image zh-lightbox-thumb lazy" width="512" data-original="https://pic4.zhimg.com/v2-8ec294de7d0f9013788e3fb5c76069ef_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8ec294de7d0f9013788e3fb5c76069ef_b.png"></figure><p>这样，就相当于上面第一个例子，上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30。我们需要这样改：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-64e8b19eeb70d9cf87c27fe4c5c0fc81_b.png" data-caption="" data-rawwidth="534" data-rawheight="154" class="origin_image zh-lightbox-thumb" width="534" data-original="https://pic2.zhimg.com/v2-64e8b19eeb70d9cf87c27fe4c5c0fc81_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-64e8b19eeb70d9cf87c27fe4c5c0fc81_hd.png" data-caption="" data-rawwidth="534" data-rawheight="154" class="origin_image zh-lightbox-thumb lazy" width="534" data-original="https://pic2.zhimg.com/v2-64e8b19eeb70d9cf87c27fe4c5c0fc81_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-64e8b19eeb70d9cf87c27fe4c5c0fc81_b.png"></figure><p>由于我们修改了轮胎的定义，为了让整个程序正常运行，我们需要做以下改动：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-82e0c12a1b26f7979ed9241e169affda_b.png" data-caption="" data-rawwidth="1186" data-rawheight="1452" class="origin_image zh-lightbox-thumb" width="1186" data-original="https://pic3.zhimg.com/v2-82e0c12a1b26f7979ed9241e169affda_r.jpg"></noscript><img src="https://pic3.zhimg.com/80/v2-82e0c12a1b26f7979ed9241e169affda_hd.png" data-caption="" data-rawwidth="1186" data-rawheight="1452" class="origin_image zh-lightbox-thumb lazy" width="1186" data-original="https://pic3.zhimg.com/v2-82e0c12a1b26f7979ed9241e169affda_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-82e0c12a1b26f7979ed9241e169affda_b.png"></figure><p>由此我们可以看到，仅仅是为了修改轮胎的构造函数，这种设计却需要<b>修改整个上层所有类的构造函数</b>！在软件工程中，<b>这样的设计几乎是不可维护的</b>——在实际工程项目中，有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。</p><p>所以我们需要进行控制反转（IoC），及上层控制下层，而不是下层控制着上层。我们用依赖注入（Dependency Injection）这种方式来实现控制反转。<b>所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制</b>”。这里我们用<b>构造方法传递的依赖注入方式</b>重新写车类的定义：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-c920a0540ce0651003a5326f6ef9891d_b.png" data-caption="" data-rawwidth="1338" data-rawheight="1424" class="origin_image zh-lightbox-thumb" width="1338" data-original="https://pic2.zhimg.com/v2-c920a0540ce0651003a5326f6ef9891d_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-c920a0540ce0651003a5326f6ef9891d_hd.png" data-caption="" data-rawwidth="1338" data-rawheight="1424" class="origin_image zh-lightbox-thumb lazy" width="1338" data-original="https://pic2.zhimg.com/v2-c920a0540ce0651003a5326f6ef9891d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c920a0540ce0651003a5326f6ef9891d_b.png"></figure><p>这里我们再把轮胎尺寸变成动态的，同样为了让整个系统顺利运行，我们需要做如下修改：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-99ad2cd809fcb86dd791ff7f65fb1779_b.png" data-caption="" data-rawwidth="1344" data-rawheight="1424" class="origin_image zh-lightbox-thumb" width="1344" data-original="https://pic2.zhimg.com/v2-99ad2cd809fcb86dd791ff7f65fb1779_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-99ad2cd809fcb86dd791ff7f65fb1779_hd.png" data-caption="" data-rawwidth="1344" data-rawheight="1424" class="origin_image zh-lightbox-thumb lazy" width="1344" data-original="https://pic2.zhimg.com/v2-99ad2cd809fcb86dd791ff7f65fb1779_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-99ad2cd809fcb86dd791ff7f65fb1779_b.png"></figure><p>看到没？这里<b>我只需要修改轮胎类就行了，不用修改其他任何上层类。</b>这显然是更容易维护的代码。不仅如此，在实际的工程中，这种设计模式还有利于<b>不同组的协同合作和单元测试：</b>比如开发这四个类的分别是四个不同的组，那么只要定义好了接口，四个不同的组可以同时进行开发而不相互受限制；而对于单元测试，如果我们要写Car类的单元测试，就只需要Mock一下Framework类传入Car就行了，而不用把Framework, Bottom, Tire全部new一遍再来构造Car。</p><p>这里我们是采用的<b>构造函数传入</b>的方式进行的依赖注入。其实还有另外两种方法：<b>Setter传递</b>和<b>接口传递</b>。这里就不多讲了，核心思路都是一样的，都是为了实现<b>控制反转</b>。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-861683acac47577c81f2b7493dd05649_b.png" data-caption="" data-rawwidth="924" data-rawheight="298" class="origin_image zh-lightbox-thumb" width="924" data-original="https://pic2.zhimg.com/v2-861683acac47577c81f2b7493dd05649_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-861683acac47577c81f2b7493dd05649_hd.png" data-caption="" data-rawwidth="924" data-rawheight="298" class="origin_image zh-lightbox-thumb lazy" width="924" data-original="https://pic2.zhimg.com/v2-861683acac47577c81f2b7493dd05649_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-861683acac47577c81f2b7493dd05649_b.png"></figure><p><br></p><figure><noscript><img src="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-d53c75e91d959acbb0d95a835212ada5_hd.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png"></figure><p>看到这里你应该能理解什么控制反转和依赖注入了。那什么是<b>控制反转容器(IoC Container)</b>呢？其实上面的例子中，对车类进行初始化的那段代码发生的地方，就是控制反转容器。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-c845802f9187953ed576e0555f76da42_b.png" data-caption="" data-rawwidth="1422" data-rawheight="628" class="origin_image zh-lightbox-thumb" width="1422" data-original="https://pic3.zhimg.com/v2-c845802f9187953ed576e0555f76da42_r.jpg"></noscript><img src="https://pic3.zhimg.com/80/v2-c845802f9187953ed576e0555f76da42_hd.png" data-caption="" data-rawwidth="1422" data-rawheight="628" class="origin_image zh-lightbox-thumb lazy" width="1422" data-original="https://pic3.zhimg.com/v2-c845802f9187953ed576e0555f76da42_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c845802f9187953ed576e0555f76da42_b.png"></figure><p>显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。<b>这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码</b>。这是引入IoC Container的第一个好处。</p><p>IoC Container的第二个好处是：<b>我们在创建实例的时候不需要了解其中的细节。</b>在上面的例子中，我们自己手动创建一个车instance时候，是从底层往上层new的：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-555b2be7d76e78511a6d6fed3304927f_b.png" data-caption="" data-rawwidth="2430" data-rawheight="168" class="origin_image zh-lightbox-thumb" width="2430" data-original="https://pic4.zhimg.com/v2-555b2be7d76e78511a6d6fed3304927f_r.jpg"></noscript><img src="https://pic4.zhimg.com/80/v2-555b2be7d76e78511a6d6fed3304927f_hd.png" data-caption="" data-rawwidth="2430" data-rawheight="168" class="origin_image zh-lightbox-thumb lazy" width="2430" data-original="https://pic4.zhimg.com/v2-555b2be7d76e78511a6d6fed3304927f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-555b2be7d76e78511a6d6fed3304927f_b.png"></figure><p>这个过程中，我们需要了解整个Car/Framework/Bottom/Tire类构造函数是怎么定义的，才能一步一步new/注入。</p><p>而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-24a96669241e81439c636e83976ba152_b.png" data-caption="" data-rawwidth="2522" data-rawheight="354" class="origin_image zh-lightbox-thumb" width="2522" data-original="https://pic3.zhimg.com/v2-24a96669241e81439c636e83976ba152_r.jpg"></noscript><img src="https://pic3.zhimg.com/80/v2-24a96669241e81439c636e83976ba152_hd.png" data-caption="" data-rawwidth="2522" data-rawheight="354" class="origin_image zh-lightbox-thumb lazy" width="2522" data-original="https://pic3.zhimg.com/v2-24a96669241e81439c636e83976ba152_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-24a96669241e81439c636e83976ba152_b.png"></figure><p>这里IoC Container可以直接隐藏具体的创建实例的细节，在我们来看它就像一个工厂：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-5ca61395f37cef73c7bbe7808f9ea219_b.png" data-caption="" data-rawwidth="2448" data-rawheight="524" class="origin_image zh-lightbox-thumb" width="2448" data-original="https://pic2.zhimg.com/v2-5ca61395f37cef73c7bbe7808f9ea219_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-5ca61395f37cef73c7bbe7808f9ea219_hd.png" data-caption="" data-rawwidth="2448" data-rawheight="524" class="origin_image zh-lightbox-thumb lazy" width="2448" data-original="https://pic2.zhimg.com/v2-5ca61395f37cef73c7bbe7808f9ea219_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5ca61395f37cef73c7bbe7808f9ea219_b.png"></figure><p>我们就像是工厂的客户。我们只需要向工厂请求一个Car实例，然后它就给我们按照Config创建了一个Car实例。我们完全不用管这个Car实例是怎么一步一步被创建出来。</p><p>实际项目中，有的Service Class可能是十年前写的，有几百个类作为它的底层。假设我们新写的一个API需要实例化这个Service，我们总不可能回头去搞清楚这几百个类的构造函数吧？IoC Container的这个特性就很完美的解决了这类问题——<b>因为这个架构要求你在写class的时候需要写相应的Config文件，所以你要初始化很久以前的Service类的时候，前人都已经写好了Config文件，你直接在需要用的地方注入这个Service就可以了</b>。这大大增加了项目的可维护性且降低了开发难度。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg"></noscript><img src="https://pic2.zhimg.com/80/v2-d53c75e91d959acbb0d95a835212ada5_hd.png" data-caption="" data-rawwidth="600" data-rawheight="61" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-d53c75e91d959acbb0d95a835212ada5_b.png"></figure><p>这里只是很粗略的讲了一下我自己对IoC和DI的理解。主要的目的是在于<b>最大限度避免晦涩难懂的专业词汇，用尽量简洁，通俗，直观的例子</b>来解释这些概念。如果让大家能有一个类似“哦！原来就是这么个玩意嘛！”的印象，我觉得就OK了。想要深入了解的话，可以上网查阅一些更权威的资料。这里推荐一下 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Dependency_injection" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Dependency injection </a> 和 <a href="https://link.zhihu.com/?target=https%3A//martinfowler.com/articles/injection.html" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Inversion of Control Containers and the Dependency Injection pattern</a> 这两篇文章，讲的很好很详细。</p></span></div><div><div class="ContentItem-time"><a target="_blank" href="/question/23277575/answer/169698662"><span data-tooltip="发布于 2017-05-15 13:51">编辑于 2017-10-25</span></a></div></div><div class="ContentItem-actions RichContent-actions"><span><button aria-label="赞同" type="button" class="Button VoteButton VoteButton--up"><svg viewBox="0 0 20 18" class="Icon VoteButton-upIcon Icon--triangle" width="9" height="16" aria-hidden="true" style="height: 16px; width: 9px;"><title></title><g><path d="M0 15.243c0-.326.088-.533.236-.896l7.98-13.204C8.57.57 9.086 0 10 0s1.43.57 1.784 1.143l7.98 13.204c.15.363.236.57.236.896 0 1.386-.875 1.9-1.955 1.9H1.955c-1.08 0-1.955-.517-1.955-1.9z"></path></g></svg>1.5K</button><button aria-label="反对" type="button" class="Button VoteButton VoteButton--down"><svg viewBox="0 0 20 18" class="Icon VoteButton-downIcon Icon--triangle" width="9" height="16" aria-hidden="true" style="height: 16px; width: 9px;"><title></title><g><path d="M0 15.243c0-.326.088-.533.236-.896l7.98-13.204C8.57.57 9.086 0 10 0s1.43.57 1.784 1.143l7.98 13.204c.15.363.236.57.236.896 0 1.386-.875 1.9-1.955 1.9H1.955c-1.08 0-1.955-.517-1.955-1.9z"></path></g></svg></button></span><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Comment Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M10.241 19.313a.97.97 0 0 0-.77.2 7.908 7.908 0 0 1-3.772 1.482.409.409 0 0 1-.38-.637 5.825 5.825 0 0 0 1.11-2.237.605.605 0 0 0-.227-.59A7.935 7.935 0 0 1 3 11.25C3 6.7 7.03 3 12 3s9 3.7 9 8.25-4.373 9.108-10.759 8.063z" fill-rule="evenodd"></path></svg></span>126 条评论</button><div class="Popover ShareMenu ContentItem-action"><div class="" id="Popover-3461-37552-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover-3461-37552-content"><button type="button" class="Button Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Share Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M2.931 7.89c-1.067.24-1.275 1.669-.318 2.207l5.277 2.908 8.168-4.776c.25-.127.477.198.273.39L9.05 14.66l.927 5.953c.18 1.084 1.593 1.376 2.182.456l9.644-15.242c.584-.892-.212-2.029-1.234-1.796L2.93 7.89z" fill-rule="evenodd"></path></svg></span>分享</button></div></div><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Star Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M5.515 19.64l.918-5.355-3.89-3.792c-.926-.902-.639-1.784.64-1.97L8.56 7.74l2.404-4.871c.572-1.16 1.5-1.16 2.072 0L15.44 7.74l5.377.782c1.28.186 1.566 1.068.64 1.97l-3.89 3.793.918 5.354c.219 1.274-.532 1.82-1.676 1.218L12 18.33l-4.808 2.528c-1.145.602-1.896.056-1.677-1.218z" fill-rule="evenodd"></path></svg></span>收藏</button><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Heart Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M2 8.437C2 5.505 4.294 3.094 7.207 3 9.243 3 11.092 4.19 12 6c.823-1.758 2.649-3 4.651-3C19.545 3 22 5.507 22 8.432 22 16.24 13.842 21 12 21 10.158 21 2 16.24 2 8.437z" fill-rule="evenodd"></path></svg></span>感谢</button><div class="Popover ContentItem-action"><button aria-label="更多" type="button" id="Popover-3461-58873-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover-3461-58873-content" class="Button Button--plain Button--withIcon Button--iconOnly"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Dots Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M5 14a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4z" fill-rule="evenodd"></path></svg></span></button></div><button data-zop-retract-question="true" type="button" class="Button ContentItem-action ContentItem-rightButton Button--plain"><span class="RichContent-collapsedText">收起</span><svg viewBox="0 0 10 6" class="Icon ContentItem-arrowIcon is-active Icon--arrow" width="10" height="16" aria-hidden="true" style="height: 16px; width: 10px;"><title></title><g><path d="M8.716.217L5.002 4 1.285.218C.99-.072.514-.072.22.218c-.294.29-.294.76 0 1.052l4.25 4.512c.292.29.77.29 1.063 0L9.78 1.27c.293-.29.293-.76 0-1.052-.295-.29-.77-.29-1.063 0z"></path></g></svg></button></div></div>

### 理解 4.

<div class="RichContent RichContent--unescapable"><div class="RichContent-inner RichContent-inner--collapsed"><span class="RichText ztext CopyrightRichText-richText" itemprop="text"><p>私以为以上各位都没有对spring ioc的精髓讲解到位。大多都在很模糊的说是什么，抽象化的表述或者含糊其辞的说概念。</p><p>ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p><p>也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。</p><p>这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。嗯，就这样，希望对题主有帮助。</p><p>==========================update===========================<br>在以上的描述中，诞生了两个专业词汇，依赖注入和控制反转<br>所谓的依赖注入，则是，甲方开放接口，在它需要的时候，能够讲乙方传递进来(注入)<br>所谓的控制反转，甲乙双方不相互依赖，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。</p><p>这就是spring IOC的思想所在，不要只谈DI IOC这些概念。</p>人之所恶在好为人师,不实知，谨慎言。</span></div><div><div class="ContentItem-time"><a target="_blank" href="/question/23277575/answer/24259844"><span data-tooltip="发布于 2014-04-09 01:08">编辑于 2014-04-09</span></a></div></div><div class="ContentItem-actions"><span><button aria-label="赞同" type="button" class="Button VoteButton VoteButton--up"><svg viewBox="0 0 20 18" class="Icon VoteButton-upIcon Icon--triangle" width="9" height="16" aria-hidden="true" style="height: 16px; width: 9px;"><title></title><g><path d="M0 15.243c0-.326.088-.533.236-.896l7.98-13.204C8.57.57 9.086 0 10 0s1.43.57 1.784 1.143l7.98 13.204c.15.363.236.57.236.896 0 1.386-.875 1.9-1.955 1.9H1.955c-1.08 0-1.955-.517-1.955-1.9z"></path></g></svg>785</button><button aria-label="反对" type="button" class="Button VoteButton VoteButton--down"><svg viewBox="0 0 20 18" class="Icon VoteButton-downIcon Icon--triangle" width="9" height="16" aria-hidden="true" style="height: 16px; width: 9px;"><title></title><g><path d="M0 15.243c0-.326.088-.533.236-.896l7.98-13.204C8.57.57 9.086 0 10 0s1.43.57 1.784 1.143l7.98 13.204c.15.363.236.57.236.896 0 1.386-.875 1.9-1.955 1.9H1.955c-1.08 0-1.955-.517-1.955-1.9z"></path></g></svg></button></span><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Comment Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M10.241 19.313a.97.97 0 0 0-.77.2 7.908 7.908 0 0 1-3.772 1.482.409.409 0 0 1-.38-.637 5.825 5.825 0 0 0 1.11-2.237.605.605 0 0 0-.227-.59A7.935 7.935 0 0 1 3 11.25C3 6.7 7.03 3 12 3s9 3.7 9 8.25-4.373 9.108-10.759 8.063z" fill-rule="evenodd"></path></svg></span>47 条评论</button><div class="Popover ShareMenu ContentItem-action"><div class="" id="Popover-7154-63704-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover-7154-63704-content"><button type="button" class="Button Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Share Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M2.931 7.89c-1.067.24-1.275 1.669-.318 2.207l5.277 2.908 8.168-4.776c.25-.127.477.198.273.39L9.05 14.66l.927 5.953c.18 1.084 1.593 1.376 2.182.456l9.644-15.242c.584-.892-.212-2.029-1.234-1.796L2.93 7.89z" fill-rule="evenodd"></path></svg></span>分享</button></div></div><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Star Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M5.515 19.64l.918-5.355-3.89-3.792c-.926-.902-.639-1.784.64-1.97L8.56 7.74l2.404-4.871c.572-1.16 1.5-1.16 2.072 0L15.44 7.74l5.377.782c1.28.186 1.566 1.068.64 1.97l-3.89 3.793.918 5.354c.219 1.274-.532 1.82-1.676 1.218L12 18.33l-4.808 2.528c-1.145.602-1.896.056-1.677-1.218z" fill-rule="evenodd"></path></svg></span>收藏</button><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Heart Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M2 8.437C2 5.505 4.294 3.094 7.207 3 9.243 3 11.092 4.19 12 6c.823-1.758 2.649-3 4.651-3C19.545 3 22 5.507 22 8.432 22 16.24 13.842 21 12 21 10.158 21 2 16.24 2 8.437z" fill-rule="evenodd"></path></svg></span>感谢</button><div class="Popover ContentItem-action"><button aria-label="更多" type="button" id="Popover-7154-61224-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover-7154-61224-content" class="Button Button--plain Button--withIcon Button--iconOnly"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Dots Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M5 14a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4z" fill-rule="evenodd"></path></svg></span></button></div></div></div>